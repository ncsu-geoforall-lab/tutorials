<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Veronica Andreo">
<meta name="dcterms.date" content="2024-08-14">

<title>Time series querying</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="time_series_query_with_vector_files/libs/clipboard/clipboard.min.js"></script>
<script src="time_series_query_with_vector_files/libs/quarto-html/quarto.js"></script>
<script src="time_series_query_with_vector_files/libs/quarto-html/popper.min.js"></script>
<script src="time_series_query_with_vector_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="time_series_query_with_vector_files/libs/quarto-html/anchor.min.js"></script>
<link href="time_series_query_with_vector_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="time_series_query_with_vector_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="time_series_query_with_vector_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="time_series_query_with_vector_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="time_series_query_with_vector_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Time series querying</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Veronica Andreo </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 14, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In this sixth part of the time series tutorials, we will go through time series querying and compare and contrast the different tools available according to their inputs, outputs and other options. We will split tools into two groups according to their name to facilitate comparisons:</p>
<ul>
<li>temporal tools: <a href="https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html">t.rast.what</a>, <a href="https://grass.osgeo.org/grass-stable/manuals/addons/t.rast.what.aggr.html">t.rast.what.aggr</a>,<a href="https://grass.osgeo.org/grass-stable/manuals/t.vect.observe.strds.html">t.vect.observe.strds</a>, <a href="https://grass.osgeo.org/grass-stable/manuals/t.vect.what.strds.html">t.vect.what.strds</a> and,</li>
<li>vector tools: <a href="https://grass.osgeo.org/grass-stable/manuals/v.what.strds.html">v.what.strds</a>, <a href="https://grass.osgeo.org/grass-stable/manuals/addons/v.what.strds.timestamp.html">v.what.strds.timestamp</a>, <a href="https://grass.osgeo.org/grass-stable/manuals/addons/v.strds.stats.html">v.strds.stats</a>.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled" title="Setup">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Setup
</div>
</div>
<div class="callout-body-container callout-body">
<p>This tutorial can be run locally or in Google Colab. However, make sure you install GRASS GIS 8.4+, download the <a href="">LST sample project</a> and set up your project as explained in the <a href="time_series_management_and_visualization.qmd">first part</a> of these time series tutorials.</p>
</div>
</div>
<section id="temporal-tools" class="level2">
<h2 class="anchored" data-anchor-id="temporal-tools">Temporal tools</h2>
<p>All the temporal tools that allow to query raster time series take either coordinates or a point vector map as inputs to sample one or various STRDS. Regarding outputs, the <em>t.rast.*</em> tools retrieve values to stdout, write them in plain text files or update the vector attribute table. In contrast, the <em>t.vect.*</em> tools output vector time series. Only two of these tools allow to do queries with temporal aggregation of the raster data either according to a fixed date or a date column in the case of <em>t.rast.what.aggr</em> or with temporal topology relations in the case of <em>t.vect.what.strds</em>.</p>
<table class="table">
<caption>Comparison of temporal tools that allow to query space time raster datasets.</caption>
<thead>
<tr class="header">
<th>Tools/<br>options</th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html">t.rast.what</a></th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/addons/t.rast.what.aggr.html">t.rast.what.aggr</a></th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/t.vect.observe.strds.html">t.vect.observe.strds</a></th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/t.vect.what.strds.html">t.vect.what.strds</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Purpose</td>
<td>Samples a STRDS at vector points and writes the output to stdout or text file with different layouts</td>
<td>Samples a STRDS at vector points and returns aggregated values to stdout or in the attribute table</td>
<td>Samples STRDSs at points from a vector map and outputs a STVDS</td>
<td>Samples a STRDS at the spatio-temporal locations of a STVDS</td>
</tr>
<tr class="even">
<td>input</td>
<td>vector (points) or coordinates and strds</td>
<td>vector (points) and strds</td>
<td>vector (points) and strds(s)</td>
<td>stvds (points) and strds</td>
</tr>
<tr class="odd">
<td>output</td>
<td>stdout or plain text file</td>
<td>vector, plain text or stdout</td>
<td>stvds</td>
<td>stvds</td>
</tr>
<tr class="even">
<td>where</td>
<td>yes</td>
<td></td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>t_where</td>
<td></td>
<td></td>
<td></td>
<td>yes</td>
</tr>
<tr class="even">
<td>spatial aggr</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>temporal aggr</td>
<td></td>
<td>yes</td>
<td></td>
<td>yes</td>
</tr>
<tr class="even">
<td>example</td>
<td>t.rast.what -n strds=A points=points output=result.txt layout=row</td>
<td>t.rast.what.aggr input=points strds=A date=“2015-05-01” granularity=“2 months”</td>
<td>t.vect.observe.strds input=points strds=A output=points_stvds vector_output=points_vector columns=A_values</td>
<td>t.vect.what.strds input=points strds=A column=A_values method=average</td>
</tr>
</tbody>
</table>
<p>Let’s see some examples. We will first randomly extract the centroids of 15 Italian regions in our study area and save them as a point vector map to query the raster time series afterwards.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create 15 random points and add attr table</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.random"</span>, </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>               npoints<span class="op">=</span><span class="dv">15</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>               restrict<span class="op">=</span><span class="st">"italy_borders_2_clip"</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>               seed<span class="op">=</span><span class="dv">47</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.addtable"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>               columns<span class="op">=</span><span class="st">"cat integer"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display polygons and points</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> gj.Map(height <span class="op">=</span> <span class="dv">500</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>points.d_vect(<span class="bu">map</span><span class="op">=</span><span class="st">"italy_borders_2_clip"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">"boundary"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>points.d_vect(<span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, icon<span class="op">=</span><span class="st">"basic/circle"</span>, size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>points.d_barscale()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>points.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Save map</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>points.save(<span class="st">"points.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate monthly LST time series</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.aggregate"</span>, </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>               basename<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>               granularity<span class="op">=</span><span class="st">"1 month"</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>               suffix<span class="op">=</span><span class="st">"gran"</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s start by using <em>t.rast.what</em> that will output the result in the standard output, i.e., the terminal, the GUI console or the Jupyter cell.</p>
<div class="cell" data-scrolled="true">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get LST monthly values for the points</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.what"</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>               points<span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>               layout<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"n"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>x|y|start|end|value 4577892.8167900704|2607156.3643725100|2014-01-01 00:00:00|2014-02-01 00:00:00|-3.3495627520159 4577892.8167900704|2607156.3643725100|2014-02-01 00:00:00|2014-03-01 00:00:00|-4.49710379464276 4577892.8167900704|2607156.3643725100|2014-03-01 00:00:00|2014-04-01 00:00:00|2.75497920866939 4577892.8167900704|2607156.3643725100|2014-04-01 00:00:00|2014-05-01 00:00:00|5.8034850260417 4577892.8167900704|2607156.3643725100|2014-05-01 00:00:00|2014-06-01 00:00:00|9.28137663810487 4577892.8167900704|2607156.3643725100|2014-06-01 00:00:00|2014-07-01 00:00:00|13.8477356770834 4577892.8167900704|2607156.3643725100|2014-07-01 00:00:00|2014-08-01 00:00:00|15.1575793850807 4577892.8167900704|2607156.3643725100|2014-08-01 00:00:00|2014-09-01 00:00:00|13.6287058971774 4577892.8167900704|2607156.3643725100|2014-09-01 00:00:00|2014-10-01 00:00:00|11.6199055989584 4577892.8167900704|2607156.3643725100|2014-10-01 00:00:00|2014-11-01 00:00:00|8.36024697580648 4577892.8167900704|2607156.3643725100|2014-11-01 00:00:00|2014-12-01 00:00:00|2.6866315104167 4577892.8167900704|2607156.3643725100|2014-12-01 00:00:00|2015-01-01 00:00:00|-1.45273122479836 4577892.8167900704|2607156.3643725100|2015-01-01 00:00:00|2015-02-01 00:00:00|-3.12071761592739</p>
<div class="callout callout-style-default callout-note callout-titled" title="Layouts">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Layouts
</div>
</div>
<div class="callout-body-container callout-body">
<p>Users can then play around with the different output layouts, i.e., <em>row, column, timerow</em>, to find the one that better suits their data pipelines.</p>
</div>
</div>
<p>Now, to exemplify the use of <em>t.rast.what.aggr</em> imagine we did some mosquito trappings in two different dates and we need to know which was the average LST the two months before the trappings. Since the dates are different, we actually need to aggregate different days. This is done on the fly (i.e., without the need to aggregate the whole raster time series) by the extension <em>t.rast.what.aggr</em>. Let’s install it and add dates to our point vector map.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install t.rast.what.aggr extension</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"t.rast.what.aggr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a new date type column</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.addcolumn"</span>, </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date date"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>               </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Add values to the date column</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.update"</span>, </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>               value<span class="op">=</span><span class="st">"2018-07-01"</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.update"</span>,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>               value<span class="op">=</span><span class="st">"2018-08-10"</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>               where<span class="op">=</span><span class="st">"cat &gt;= '9'"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect dates</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"sampling_points"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will use the daily time series in this case to get the aggregation period right.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get aggregated LST values</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.what.aggr"</span>, </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>               date_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>               granularity<span class="op">=</span><span class="st">"2 months"</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"c"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s display the result by converting the attribute table into a Pandas DataFrame.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Question">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question
</div>
</div>
<div class="callout-body-container callout-body">
<p>What would be the result if we use the monthly time series?</p>
</div>
</div>
<p>Let’s demonstrate now the use of <em>t.vect.observe.strds</em> and <em>t.vect.what.strds</em>. These tools, as mentioned above, output a vector time series or stvds. Vector time series in GRASS GIS can be created either from a series of vector maps (especially if features/geometries vary in time) or from layers added to a single vector map (i.e., features are always the same, as in the case of meteorological stations).</p>
<p>We start with <em>t.vect.observe.strds</em>. It will create a new vector map with as many layers as raster maps there are in the strds we are querying and it will register these in a stvds.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.observe.strds"</span>,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>               vector_output<span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>               columns<span class="op">=</span><span class="st">"lst"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the stvds is created</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.info"</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>               <span class="bu">type</span><span class="op">=</span><span class="st">"stvds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check number of layers in the vector map</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>gs.vector_info(<span class="st">"sp_lst_monthly"</span>)[<span class="st">"num_dblinks"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check one layer</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"sp_lst_monthly"</span>, layer<span class="op">=</span><span class="dv">7</span>)[<span class="st">"values"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-scrolled="true">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check all layers</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.db.select"</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s now compare the values obtained by querying the monthly LST time series with those resulting from aggregating the daily LST time series. They should be the same. For that we need to specify the sampling relation. The temporal tool that allows to specify sampling relations and do temporal aggregation is <em>t.vect.what.strds</em>. It requires a stvds as input, so we’ll use the one we just obtained above. We also specify the <em>start</em> relation, so all maps in the strds which start time matches the stvds will be aggregated. Let’s see this graphically before running the tool.</p>
<p><img src="img/comparison_of_granularities.png" class="img-fluid"></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.what.strds"</span>, </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>, </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_new"</span>, </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>, </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>               sampling<span class="op">=</span><span class="st">"start"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-scrolled="true">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.db.select"</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As expected, results are exactly the same! So, if you are constrained by disk space for example, you don’t need to aggregate your entire strds if you only need aggregated values for a set of points.</p>
</section>
<section id="vector-tools" class="level2">
<h2 class="anchored" data-anchor-id="vector-tools">Vector tools</h2>
<p>The main difference between temporal and vector tools to query raster time series is that vector tools can update the attribute table of the input vector without creating more layers. Regarding inputs, both <em>v.what.strds</em> and <em>v.what.strds.timestamp</em> take a point vector map as input, while <em>v.strds.stats</em> takes a line or polygon vector map and performs spatial aggregation, i.e.&nbsp;zonal stats over the full or a part of the strds. The extension <em>v.what.strds.timestamp</em>, somehow similar to <em>t.rast.what.aggr</em>, offers the possibility of reading input points’ date information from a column in the attribute table and only performs the query for the dates that match. It also offers spatial interpolation of the four nearest pixels.</p>
<table class="table">
<caption>Comparison of vector tools that allow to query space time raster datasets.</caption>
<thead>
<tr class="header">
<th>Tools/<br>options</th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/v.what.strds.html">v.what.strds</a></th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/addons/v.what.strds.timestamp.html">v.what.strds.timestamp</a></th>
<th><a href="https://grass.osgeo.org/grass-stable/manuals/addons/v.strds.stats.html">v.strds.stats</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Purpose</td>
<td>Retrieves raster values from STRDSs using a point vector map</td>
<td>Matches points with timestamp in the attribute table with STRDSs based on point locations in space and time, and updates the input vector’s attribute table</td>
<td>Calculates zonal statistics from STRDSs and uploads values to attribute columns of a new vector map</td>
</tr>
<tr class="even">
<td>input</td>
<td>vector (points) and strds(s)</td>
<td>vector (points) and strds(s)</td>
<td>vector (lines or polygons) and strds(s)</td>
</tr>
<tr class="odd">
<td>output</td>
<td>vector</td>
<td>vector</td>
<td>vector</td>
</tr>
<tr class="even">
<td>where</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>t_where</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="even">
<td>spatial aggr</td>
<td></td>
<td></td>
<td>yes</td>
</tr>
<tr class="odd">
<td>temporal aggr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>spatial interp</td>
<td></td>
<td>yes</td>
<td></td>
</tr>
<tr class="odd">
<td>example</td>
<td>v.what.strds -u input=points strds=A</td>
<td>v.what.strds.timestamp input=points timestamp_column=sampling_time column=A_at_sampling_time strds=A</td>
<td>v.strds.stats input=areas strds=A output=areas_new method=average</td>
</tr>
</tbody>
</table>
<p>Let’s go through the usage of the vector tools to query raster time series now. When we run <em>v.what.strds</em> to query strds we can either save the results in a new vector map or update the input vector attribute table by setting the <code>u</code> flag. In this case, we’ll create a new vector map and do a temporal selection.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Run v.what.strds with temporal selection</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds"</span>,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sp_lst_monthly_2014"</span>,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"start_time &lt;= '2015-01-01'"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s check the new vector created. It contains a new column per map in the queried strds.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sp_lst_monthly_2014"</span>, </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The tool <em>v.what.strds.timestamp</em> is an extension so we need to install it first. It will by default update the input vector attribute table with a column that needs to be specified by the user. Furthermore, it offers spatial interpolation of the four nearest cells via the <code>i</code> flag. Let’s compare the results with and without it.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"v.what.strds.timestamp"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># with spatial interp of neighbor cells</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds.timestamp"</span>,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>               timestamp_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_sampling_date_i"</span>,</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"i"</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>               </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># without spatial interp of neighbor cells</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds.timestamp"</span>,</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>               timestamp_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_sampling_date_no_i"</span>,</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s check the results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we’ll extract zonal statistics of a raster time series. For this, we need either a line or polygon vector map as input. We’ll use the map of italian municipalities and demonstrate the use of spatial (<code>where</code>) and temporal (<code>t_where</code>) selection.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install v.strds.stats extension</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"v.strds.stats"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract August average LST for Milano municipality</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.strds.stats"</span>,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3"</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>               where<span class="op">=</span><span class="st">"NAME_3 == 'Milano'"</span>,</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"strftime('%m', start_time)='08'"</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"milano_lst_august"</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"milano_lst_august"</span>)[<span class="st">"values"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s now try to find out which municipality in northern Italy had the highest August average temperature each year?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clip municipalities to computational region</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.clip"</span>, </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3"</span>, </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"italy_borders_3_clip"</span>, </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"r"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract summer average LST municipalities</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.strds.stats"</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3_clip"</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"strftime('%m', start_time)='08'"</span>,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"municip_lst_august"</span>,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the output table</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"municip_lst_august"</span>, </span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>table <span class="op">=</span> pd.DataFrame(data[<span class="st">'records'</span>])</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>table</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List with column names</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="bu">list</span>(table.columns[<span class="op">-</span><span class="dv">5</span>:])</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Dictionary to store results</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols:</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the maximum value in the column</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    max_value <span class="op">=</span> table[col].<span class="bu">max</span>()</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the index of the row with the maximum value</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    max_index <span class="op">=</span> table[col].idxmax()</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the corresponding value in column 'D'</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    municipality <span class="op">=</span> table.loc[max_index, <span class="st">"NAME_3"</span>]</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the results</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    results[col] <span class="op">=</span> {<span class="st">'max_value'</span>: max_value, <span class="st">'municipality'</span>: municipality}</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the results</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, res <span class="kw">in</span> results.items():</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">':"</span>)</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Maximum value: </span><span class="sc">{</span>res[<span class="st">'max_value'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Municipality name: </span><span class="sc">{</span>res[<span class="st">'municipality'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The highest average temperature in August varied among years and municipalities, however, Campi Bisenzio in the province of Florence, had the highest value both in 2016 and 2017.</p>
<!-- how to get the max of each new col -->
<!-- write the result -->
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div class="smaller">
<p>Development of this tutorial was funded by the US <a href="https://www.nsf.gov/">National Science Foundation (NSF)</a>, award <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=2303651">2303651</a>.</p>
</div>
<!-- -->

</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb30" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Time series querying</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> Veronica Andreo</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> today</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co">    code-copy: true</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: false</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">  eval: false</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co">  keep-ipynb: true</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="an">editor:</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="co">  markdown:</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="co">    wrap: 80</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>In this sixth part of the time series tutorials, we will go through time series</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>querying and compare and contrast the different tools available according to </span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>their inputs, outputs and other options. </span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>We will split tools into two groups according to their name to facilitate </span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>comparisons:</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>temporal tools: <span class="co">[</span><span class="ot">t.rast.what</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html)</span>, <span class="co">[</span><span class="ot">t.rast.what.aggr</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/t.rast.what.aggr.html)</span>,<span class="co">[</span><span class="ot">t.vect.observe.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.vect.observe.strds.html)</span>, <span class="co">[</span><span class="ot">t.vect.what.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.vect.what.strds.html)</span> and, </span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>vector tools: <span class="co">[</span><span class="ot">v.what.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/v.what.strds.html)</span>, <span class="co">[</span><span class="ot">v.what.strds.timestamp</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/v.what.strds.timestamp.html)</span>, <span class="co">[</span><span class="ot">v.strds.stats</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/v.strds.stats.html)</span>.</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>::: {.callout-note title="Setup"}</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>This tutorial can be run locally or in Google Colab. However, make sure you</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>install GRASS GIS 8.4+, download the </span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">LST sample project</span><span class="co">]()</span> </span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>and set up your project as explained in the </span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">first part</span><span class="co">](time_series_management_and_visualization.qmd)</span> of these time</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>series tutorials.</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> subprocess</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a><span class="co"># GRASS GIS database variables</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>grassbin <span class="op">=</span> <span class="st">"grass-dev"</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>grassdata <span class="op">=</span> os.path.join(os.path.expanduser(<span class="st">'~'</span>), <span class="st">"grassdata"</span>)</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>project <span class="op">=</span> <span class="st">"eu_laea"</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>mapset <span class="op">=</span> <span class="st">"italy_LST_daily"</span></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>sys.path.append(</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    subprocess.check_output([grassbin, <span class="st">"--config"</span>, <span class="st">"python_path"</span>], text<span class="op">=</span><span class="va">True</span>).strip()</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Import the GRASS GIS packages we need</span></span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> grass.script <span class="im">as</span> gs</span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> grass.jupyter <span class="im">as</span> gj</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Start the GRASS GIS Session</span></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a>session <span class="op">=</span> gj.init(grassdata, project, mapset)<span class="op">;</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a><span class="fu">## Temporal tools</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>All the temporal tools that allow to query raster time series take either </span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a>coordinates or a point vector map as inputs to sample one or various STRDS. </span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a>Regarding outputs, the *t.rast.\** tools retrieve values to stdout, write</span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a>them in plain text files or update the vector attribute table. In contrast, </span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a>the *t.vect.\** tools output vector time series. Only two of these tools</span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a>allow to do queries with temporal aggregation of the raster data either </span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a>according to a fixed date or a date column in the case of</span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a>*t.rast.what.aggr* or with temporal topology relations in the case of </span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a>*t.vect.what.strds*.</span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a>: Comparison of temporal tools that allow to query space time raster datasets.</span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a>| Tools/&lt;br&gt;options | <span class="co">[</span><span class="ot">t.rast.what</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html)</span> | <span class="co">[</span><span class="ot">t.rast.what.aggr</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/t.rast.what.aggr.html)</span> | <span class="co">[</span><span class="ot">t.vect.observe.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.vect.observe.strds.html)</span> | <span class="co">[</span><span class="ot">t.vect.what.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/t.vect.what.strds.html)</span> |</span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a>|---|---|---|---|---|</span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a>| Purpose | Samples a STRDS at vector points and writes the output to stdout or text file with different layouts | Samples a STRDS at vector points and returns aggregated values  to stdout or in the attribute table | Samples STRDSs at points from a vector map and outputs a STVDS | Samples a STRDS at the spatio-temporal locations of a STVDS |</span>
<span id="cb30-89"><a href="#cb30-89" aria-hidden="true" tabindex="-1"></a>| input | vector (points) or coordinates and strds | vector (points) and strds | vector (points) and strds(s) | stvds (points) and strds |</span>
<span id="cb30-90"><a href="#cb30-90" aria-hidden="true" tabindex="-1"></a>| output | stdout or plain text file | vector, plain text or stdout | stvds | stvds |</span>
<span id="cb30-91"><a href="#cb30-91" aria-hidden="true" tabindex="-1"></a>| where | yes |  | yes | yes |</span>
<span id="cb30-92"><a href="#cb30-92" aria-hidden="true" tabindex="-1"></a>| t_where |  |  |  | yes |</span>
<span id="cb30-93"><a href="#cb30-93" aria-hidden="true" tabindex="-1"></a>| spatial aggr |  |  |  |  |</span>
<span id="cb30-94"><a href="#cb30-94" aria-hidden="true" tabindex="-1"></a>| temporal aggr |  | yes |  | yes |</span>
<span id="cb30-95"><a href="#cb30-95" aria-hidden="true" tabindex="-1"></a>| example | t.rast.what -n strds=A points=points output=result.txt layout=row | t.rast.what.aggr input=points strds=A date="2015-05-01" granularity="2 months" | t.vect.observe.strds input=points strds=A output=points_stvds vector_output=points_vector columns=A_values | t.vect.what.strds input=points strds=A column=A_values method=average |</span>
<span id="cb30-96"><a href="#cb30-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-97"><a href="#cb30-97" aria-hidden="true" tabindex="-1"></a>Let's see some examples. We will first randomly extract the centroids of 15 </span>
<span id="cb30-98"><a href="#cb30-98" aria-hidden="true" tabindex="-1"></a>Italian regions in our study area and save them as a point vector map to</span>
<span id="cb30-99"><a href="#cb30-99" aria-hidden="true" tabindex="-1"></a>query the raster time series afterwards.</span>
<span id="cb30-100"><a href="#cb30-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-103"><a href="#cb30-103" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-104"><a href="#cb30-104" aria-hidden="true" tabindex="-1"></a><span class="co"># Create 15 random points and add attr table</span></span>
<span id="cb30-105"><a href="#cb30-105" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.random"</span>, </span>
<span id="cb30-106"><a href="#cb30-106" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-107"><a href="#cb30-107" aria-hidden="true" tabindex="-1"></a>               npoints<span class="op">=</span><span class="dv">15</span>,</span>
<span id="cb30-108"><a href="#cb30-108" aria-hidden="true" tabindex="-1"></a>               restrict<span class="op">=</span><span class="st">"italy_borders_2_clip"</span>,</span>
<span id="cb30-109"><a href="#cb30-109" aria-hidden="true" tabindex="-1"></a>               seed<span class="op">=</span><span class="dv">47</span>)</span>
<span id="cb30-110"><a href="#cb30-110" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.addtable"</span>,</span>
<span id="cb30-111"><a href="#cb30-111" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-112"><a href="#cb30-112" aria-hidden="true" tabindex="-1"></a>               columns<span class="op">=</span><span class="st">"cat integer"</span>)</span>
<span id="cb30-113"><a href="#cb30-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-114"><a href="#cb30-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-117"><a href="#cb30-117" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-118"><a href="#cb30-118" aria-hidden="true" tabindex="-1"></a><span class="co"># Display polygons and points</span></span>
<span id="cb30-119"><a href="#cb30-119" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> gj.Map(height <span class="op">=</span> <span class="dv">500</span>)</span>
<span id="cb30-120"><a href="#cb30-120" aria-hidden="true" tabindex="-1"></a>points.d_vect(<span class="bu">map</span><span class="op">=</span><span class="st">"italy_borders_2_clip"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">"boundary"</span>)</span>
<span id="cb30-121"><a href="#cb30-121" aria-hidden="true" tabindex="-1"></a>points.d_vect(<span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, icon<span class="op">=</span><span class="st">"basic/circle"</span>, size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb30-122"><a href="#cb30-122" aria-hidden="true" tabindex="-1"></a>points.d_barscale()</span>
<span id="cb30-123"><a href="#cb30-123" aria-hidden="true" tabindex="-1"></a>points.show()</span>
<span id="cb30-124"><a href="#cb30-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-125"><a href="#cb30-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-128"><a href="#cb30-128" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-129"><a href="#cb30-129" aria-hidden="true" tabindex="-1"></a><span class="co"># Save map</span></span>
<span id="cb30-130"><a href="#cb30-130" aria-hidden="true" tabindex="-1"></a>points.save(<span class="st">"points.png"</span>)</span>
<span id="cb30-131"><a href="#cb30-131" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-132"><a href="#cb30-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-135"><a href="#cb30-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-136"><a href="#cb30-136" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate monthly LST time series</span></span>
<span id="cb30-137"><a href="#cb30-137" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.aggregate"</span>, </span>
<span id="cb30-138"><a href="#cb30-138" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb30-139"><a href="#cb30-139" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-140"><a href="#cb30-140" aria-hidden="true" tabindex="-1"></a>               basename<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-141"><a href="#cb30-141" aria-hidden="true" tabindex="-1"></a>               granularity<span class="op">=</span><span class="st">"1 month"</span>,</span>
<span id="cb30-142"><a href="#cb30-142" aria-hidden="true" tabindex="-1"></a>               suffix<span class="op">=</span><span class="st">"gran"</span>,</span>
<span id="cb30-143"><a href="#cb30-143" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span>
<span id="cb30-144"><a href="#cb30-144" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-145"><a href="#cb30-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-146"><a href="#cb30-146" aria-hidden="true" tabindex="-1"></a>Let's start by using *t.rast.what* that will output the result in the standard</span>
<span id="cb30-147"><a href="#cb30-147" aria-hidden="true" tabindex="-1"></a>output, i.e., the terminal, the GUI console or the Jupyter cell.</span>
<span id="cb30-148"><a href="#cb30-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-151"><a href="#cb30-151" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-152"><a href="#cb30-152" aria-hidden="true" tabindex="-1"></a><span class="co">#| scrolled: true</span></span>
<span id="cb30-153"><a href="#cb30-153" aria-hidden="true" tabindex="-1"></a><span class="co"># Get LST monthly values for the points</span></span>
<span id="cb30-154"><a href="#cb30-154" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.what"</span>,</span>
<span id="cb30-155"><a href="#cb30-155" aria-hidden="true" tabindex="-1"></a>               points<span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-156"><a href="#cb30-156" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-157"><a href="#cb30-157" aria-hidden="true" tabindex="-1"></a>               layout<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb30-158"><a href="#cb30-158" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"n"</span>)</span>
<span id="cb30-159"><a href="#cb30-159" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-160"><a href="#cb30-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-161"><a href="#cb30-161" aria-hidden="true" tabindex="-1"></a>x|y|start|end|value</span>
<span id="cb30-162"><a href="#cb30-162" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-01-01 00:00:00|2014-02-01 00:00:00|-3.3495627520159</span>
<span id="cb30-163"><a href="#cb30-163" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-02-01 00:00:00|2014-03-01 00:00:00|-4.49710379464276</span>
<span id="cb30-164"><a href="#cb30-164" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-03-01 00:00:00|2014-04-01 00:00:00|2.75497920866939</span>
<span id="cb30-165"><a href="#cb30-165" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-04-01 00:00:00|2014-05-01 00:00:00|5.8034850260417</span>
<span id="cb30-166"><a href="#cb30-166" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-05-01 00:00:00|2014-06-01 00:00:00|9.28137663810487</span>
<span id="cb30-167"><a href="#cb30-167" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-06-01 00:00:00|2014-07-01 00:00:00|13.8477356770834</span>
<span id="cb30-168"><a href="#cb30-168" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-07-01 00:00:00|2014-08-01 00:00:00|15.1575793850807</span>
<span id="cb30-169"><a href="#cb30-169" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-08-01 00:00:00|2014-09-01 00:00:00|13.6287058971774</span>
<span id="cb30-170"><a href="#cb30-170" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-09-01 00:00:00|2014-10-01 00:00:00|11.6199055989584</span>
<span id="cb30-171"><a href="#cb30-171" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-10-01 00:00:00|2014-11-01 00:00:00|8.36024697580648</span>
<span id="cb30-172"><a href="#cb30-172" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-11-01 00:00:00|2014-12-01 00:00:00|2.6866315104167</span>
<span id="cb30-173"><a href="#cb30-173" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2014-12-01 00:00:00|2015-01-01 00:00:00|-1.45273122479836</span>
<span id="cb30-174"><a href="#cb30-174" aria-hidden="true" tabindex="-1"></a>4577892.8167900704|2607156.3643725100|2015-01-01 00:00:00|2015-02-01 00:00:00|-3.12071761592739</span>
<span id="cb30-175"><a href="#cb30-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-176"><a href="#cb30-176" aria-hidden="true" tabindex="-1"></a>::: {.callout-note title="Layouts"}</span>
<span id="cb30-177"><a href="#cb30-177" aria-hidden="true" tabindex="-1"></a>Users can then play around with the different output layouts, i.e., </span>
<span id="cb30-178"><a href="#cb30-178" aria-hidden="true" tabindex="-1"></a>*row, column, timerow*, to find the one that better suits their data</span>
<span id="cb30-179"><a href="#cb30-179" aria-hidden="true" tabindex="-1"></a>pipelines. </span>
<span id="cb30-180"><a href="#cb30-180" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-181"><a href="#cb30-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-182"><a href="#cb30-182" aria-hidden="true" tabindex="-1"></a>Now, to exemplify the use of *t.rast.what.aggr* imagine we did some mosquito</span>
<span id="cb30-183"><a href="#cb30-183" aria-hidden="true" tabindex="-1"></a>trappings in two different dates and we need to know which was the average</span>
<span id="cb30-184"><a href="#cb30-184" aria-hidden="true" tabindex="-1"></a>LST the two months before the trappings. Since the dates are different, we</span>
<span id="cb30-185"><a href="#cb30-185" aria-hidden="true" tabindex="-1"></a>actually need to aggregate different days. This is done on the fly (i.e., </span>
<span id="cb30-186"><a href="#cb30-186" aria-hidden="true" tabindex="-1"></a>without the need to aggregate the whole raster time series) by the extension </span>
<span id="cb30-187"><a href="#cb30-187" aria-hidden="true" tabindex="-1"></a>*t.rast.what.aggr*. Let's install it and add dates to our point vector map.</span>
<span id="cb30-188"><a href="#cb30-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-191"><a href="#cb30-191" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-192"><a href="#cb30-192" aria-hidden="true" tabindex="-1"></a><span class="co"># Install t.rast.what.aggr extension</span></span>
<span id="cb30-193"><a href="#cb30-193" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"t.rast.what.aggr"</span>)</span>
<span id="cb30-194"><a href="#cb30-194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-195"><a href="#cb30-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-198"><a href="#cb30-198" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-199"><a href="#cb30-199" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a new date type column</span></span>
<span id="cb30-200"><a href="#cb30-200" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.addcolumn"</span>, </span>
<span id="cb30-201"><a href="#cb30-201" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-202"><a href="#cb30-202" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date date"</span>)</span>
<span id="cb30-203"><a href="#cb30-203" aria-hidden="true" tabindex="-1"></a>               </span>
<span id="cb30-204"><a href="#cb30-204" aria-hidden="true" tabindex="-1"></a><span class="co"># Add values to the date column</span></span>
<span id="cb30-205"><a href="#cb30-205" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.update"</span>, </span>
<span id="cb30-206"><a href="#cb30-206" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb30-207"><a href="#cb30-207" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb30-208"><a href="#cb30-208" aria-hidden="true" tabindex="-1"></a>               value<span class="op">=</span><span class="st">"2018-07-01"</span>)</span>
<span id="cb30-209"><a href="#cb30-209" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.db.update"</span>,</span>
<span id="cb30-210"><a href="#cb30-210" aria-hidden="true" tabindex="-1"></a>               <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-211"><a href="#cb30-211" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb30-212"><a href="#cb30-212" aria-hidden="true" tabindex="-1"></a>               value<span class="op">=</span><span class="st">"2018-08-10"</span>,</span>
<span id="cb30-213"><a href="#cb30-213" aria-hidden="true" tabindex="-1"></a>               where<span class="op">=</span><span class="st">"cat &gt;= '9'"</span>)</span>
<span id="cb30-214"><a href="#cb30-214" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-215"><a href="#cb30-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-218"><a href="#cb30-218" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-219"><a href="#cb30-219" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect dates</span></span>
<span id="cb30-220"><a href="#cb30-220" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"sampling_points"</span>)</span>
<span id="cb30-221"><a href="#cb30-221" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-222"><a href="#cb30-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-223"><a href="#cb30-223" aria-hidden="true" tabindex="-1"></a>We will use the daily time series in this case to get the aggregation </span>
<span id="cb30-224"><a href="#cb30-224" aria-hidden="true" tabindex="-1"></a>period right.</span>
<span id="cb30-225"><a href="#cb30-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-228"><a href="#cb30-228" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-229"><a href="#cb30-229" aria-hidden="true" tabindex="-1"></a><span class="co"># Get aggregated LST values</span></span>
<span id="cb30-230"><a href="#cb30-230" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.rast.what.aggr"</span>, </span>
<span id="cb30-231"><a href="#cb30-231" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb30-232"><a href="#cb30-232" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb30-233"><a href="#cb30-233" aria-hidden="true" tabindex="-1"></a>               date_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb30-234"><a href="#cb30-234" aria-hidden="true" tabindex="-1"></a>               granularity<span class="op">=</span><span class="st">"2 months"</span>,</span>
<span id="cb30-235"><a href="#cb30-235" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>,</span>
<span id="cb30-236"><a href="#cb30-236" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"c"</span>)</span>
<span id="cb30-237"><a href="#cb30-237" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-238"><a href="#cb30-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-239"><a href="#cb30-239" aria-hidden="true" tabindex="-1"></a>Let's display the result by converting the attribute table into a Pandas </span>
<span id="cb30-240"><a href="#cb30-240" aria-hidden="true" tabindex="-1"></a>DataFrame.</span>
<span id="cb30-241"><a href="#cb30-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-244"><a href="#cb30-244" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-245"><a href="#cb30-245" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb30-246"><a href="#cb30-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-247"><a href="#cb30-247" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb30-248"><a href="#cb30-248" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb30-249"><a href="#cb30-249" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb30-250"><a href="#cb30-250" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb30-251"><a href="#cb30-251" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span>
<span id="cb30-252"><a href="#cb30-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-253"><a href="#cb30-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-254"><a href="#cb30-254" aria-hidden="true" tabindex="-1"></a>:::{.callout-note title="Question"}</span>
<span id="cb30-255"><a href="#cb30-255" aria-hidden="true" tabindex="-1"></a>What would be the result if we use the monthly time series?</span>
<span id="cb30-256"><a href="#cb30-256" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-257"><a href="#cb30-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-258"><a href="#cb30-258" aria-hidden="true" tabindex="-1"></a>Let's demonstrate now the use of *t.vect.observe.strds* and </span>
<span id="cb30-259"><a href="#cb30-259" aria-hidden="true" tabindex="-1"></a>*t.vect.what.strds*. These tools, as mentioned above, output a vector </span>
<span id="cb30-260"><a href="#cb30-260" aria-hidden="true" tabindex="-1"></a>time series or stvds. Vector time series in GRASS GIS can be created either </span>
<span id="cb30-261"><a href="#cb30-261" aria-hidden="true" tabindex="-1"></a>from a series of vector maps (especially if features/geometries vary in time) </span>
<span id="cb30-262"><a href="#cb30-262" aria-hidden="true" tabindex="-1"></a>or from layers added to a single vector map (i.e., features are always the </span>
<span id="cb30-263"><a href="#cb30-263" aria-hidden="true" tabindex="-1"></a>same, as in the case of meteorological stations).</span>
<span id="cb30-264"><a href="#cb30-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-265"><a href="#cb30-265" aria-hidden="true" tabindex="-1"></a>We start with *t.vect.observe.strds*. It will create a new vector map with </span>
<span id="cb30-266"><a href="#cb30-266" aria-hidden="true" tabindex="-1"></a>as many layers as raster maps there are in the strds we are querying and it </span>
<span id="cb30-267"><a href="#cb30-267" aria-hidden="true" tabindex="-1"></a>will register these in a stvds.</span>
<span id="cb30-268"><a href="#cb30-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-271"><a href="#cb30-271" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-272"><a href="#cb30-272" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.observe.strds"</span>,</span>
<span id="cb30-273"><a href="#cb30-273" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-274"><a href="#cb30-274" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-275"><a href="#cb30-275" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb30-276"><a href="#cb30-276" aria-hidden="true" tabindex="-1"></a>               vector_output<span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb30-277"><a href="#cb30-277" aria-hidden="true" tabindex="-1"></a>               columns<span class="op">=</span><span class="st">"lst"</span>)</span>
<span id="cb30-278"><a href="#cb30-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-279"><a href="#cb30-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-282"><a href="#cb30-282" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-283"><a href="#cb30-283" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the stvds is created</span></span>
<span id="cb30-284"><a href="#cb30-284" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.info"</span>,</span>
<span id="cb30-285"><a href="#cb30-285" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>,</span>
<span id="cb30-286"><a href="#cb30-286" aria-hidden="true" tabindex="-1"></a>               <span class="bu">type</span><span class="op">=</span><span class="st">"stvds"</span>)</span>
<span id="cb30-287"><a href="#cb30-287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-288"><a href="#cb30-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-291"><a href="#cb30-291" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-292"><a href="#cb30-292" aria-hidden="true" tabindex="-1"></a><span class="co"># Check number of layers in the vector map</span></span>
<span id="cb30-293"><a href="#cb30-293" aria-hidden="true" tabindex="-1"></a>gs.vector_info(<span class="st">"sp_lst_monthly"</span>)[<span class="st">"num_dblinks"</span>]</span>
<span id="cb30-294"><a href="#cb30-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-295"><a href="#cb30-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-298"><a href="#cb30-298" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-299"><a href="#cb30-299" aria-hidden="true" tabindex="-1"></a><span class="co"># Check one layer</span></span>
<span id="cb30-300"><a href="#cb30-300" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"sp_lst_monthly"</span>, layer<span class="op">=</span><span class="dv">7</span>)[<span class="st">"values"</span>]</span>
<span id="cb30-301"><a href="#cb30-301" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-302"><a href="#cb30-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-305"><a href="#cb30-305" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-306"><a href="#cb30-306" aria-hidden="true" tabindex="-1"></a><span class="co">#| scrolled: true</span></span>
<span id="cb30-307"><a href="#cb30-307" aria-hidden="true" tabindex="-1"></a><span class="co"># Check all layers</span></span>
<span id="cb30-308"><a href="#cb30-308" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.db.select"</span>,</span>
<span id="cb30-309"><a href="#cb30-309" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>)</span>
<span id="cb30-310"><a href="#cb30-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-311"><a href="#cb30-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-312"><a href="#cb30-312" aria-hidden="true" tabindex="-1"></a>Let's now compare the values obtained by querying the monthly LST time series</span>
<span id="cb30-313"><a href="#cb30-313" aria-hidden="true" tabindex="-1"></a>with those resulting from aggregating the daily LST time series. They should </span>
<span id="cb30-314"><a href="#cb30-314" aria-hidden="true" tabindex="-1"></a>be the same. For that we need to specify the sampling relation. The temporal </span>
<span id="cb30-315"><a href="#cb30-315" aria-hidden="true" tabindex="-1"></a>tool that allows to specify sampling relations and do temporal aggregation is</span>
<span id="cb30-316"><a href="#cb30-316" aria-hidden="true" tabindex="-1"></a>*t.vect.what.strds*. It requires a stvds as input, so we'll use the one we </span>
<span id="cb30-317"><a href="#cb30-317" aria-hidden="true" tabindex="-1"></a>just obtained above. We also specify the *start* relation, so all maps in the </span>
<span id="cb30-318"><a href="#cb30-318" aria-hidden="true" tabindex="-1"></a>strds which start time matches the stvds will be aggregated. Let's see this </span>
<span id="cb30-319"><a href="#cb30-319" aria-hidden="true" tabindex="-1"></a>graphically before running the tool.</span>
<span id="cb30-320"><a href="#cb30-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-321"><a href="#cb30-321" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/comparison_of_granularities.png)</span></span>
<span id="cb30-322"><a href="#cb30-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-325"><a href="#cb30-325" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-326"><a href="#cb30-326" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.what.strds"</span>, </span>
<span id="cb30-327"><a href="#cb30-327" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>, </span>
<span id="cb30-328"><a href="#cb30-328" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>, </span>
<span id="cb30-329"><a href="#cb30-329" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_new"</span>, </span>
<span id="cb30-330"><a href="#cb30-330" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>, </span>
<span id="cb30-331"><a href="#cb30-331" aria-hidden="true" tabindex="-1"></a>               sampling<span class="op">=</span><span class="st">"start"</span>)</span>
<span id="cb30-332"><a href="#cb30-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-333"><a href="#cb30-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-336"><a href="#cb30-336" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-337"><a href="#cb30-337" aria-hidden="true" tabindex="-1"></a><span class="co">#| scrolled: true</span></span>
<span id="cb30-338"><a href="#cb30-338" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"t.vect.db.select"</span>,</span>
<span id="cb30-339"><a href="#cb30-339" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sp_lst_monthly"</span>)</span>
<span id="cb30-340"><a href="#cb30-340" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-341"><a href="#cb30-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-342"><a href="#cb30-342" aria-hidden="true" tabindex="-1"></a>As expected, results are exactly the same! So, if you are constrained by disk</span>
<span id="cb30-343"><a href="#cb30-343" aria-hidden="true" tabindex="-1"></a>space for example, you don't need to aggregate your entire strds if you only</span>
<span id="cb30-344"><a href="#cb30-344" aria-hidden="true" tabindex="-1"></a>need aggregated values for a set of points.</span>
<span id="cb30-345"><a href="#cb30-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-346"><a href="#cb30-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-347"><a href="#cb30-347" aria-hidden="true" tabindex="-1"></a><span class="fu">## Vector tools</span></span>
<span id="cb30-348"><a href="#cb30-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-349"><a href="#cb30-349" aria-hidden="true" tabindex="-1"></a>The main difference between temporal and vector tools to query raster time</span>
<span id="cb30-350"><a href="#cb30-350" aria-hidden="true" tabindex="-1"></a>series is that vector tools can update the attribute table of the input vector</span>
<span id="cb30-351"><a href="#cb30-351" aria-hidden="true" tabindex="-1"></a>without creating more layers. Regarding inputs, both *v.what.strds* and </span>
<span id="cb30-352"><a href="#cb30-352" aria-hidden="true" tabindex="-1"></a>*v.what.strds.timestamp* take a point vector map as input, while *v.strds.stats*</span>
<span id="cb30-353"><a href="#cb30-353" aria-hidden="true" tabindex="-1"></a>takes a line or polygon vector map and performs spatial aggregation, </span>
<span id="cb30-354"><a href="#cb30-354" aria-hidden="true" tabindex="-1"></a>i.e. zonal stats over the full or a part of the strds. </span>
<span id="cb30-355"><a href="#cb30-355" aria-hidden="true" tabindex="-1"></a>The extension *v.what.strds.timestamp*, somehow similar to *t.rast.what.aggr*,</span>
<span id="cb30-356"><a href="#cb30-356" aria-hidden="true" tabindex="-1"></a>offers the possibility of reading input points' date information from a column</span>
<span id="cb30-357"><a href="#cb30-357" aria-hidden="true" tabindex="-1"></a>in the attribute table and only performs the query for the dates that match. It</span>
<span id="cb30-358"><a href="#cb30-358" aria-hidden="true" tabindex="-1"></a>also offers spatial interpolation of the four nearest pixels.</span>
<span id="cb30-359"><a href="#cb30-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-360"><a href="#cb30-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-361"><a href="#cb30-361" aria-hidden="true" tabindex="-1"></a>: Comparison of vector tools that allow to query space time raster datasets.</span>
<span id="cb30-362"><a href="#cb30-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-363"><a href="#cb30-363" aria-hidden="true" tabindex="-1"></a>| Tools/&lt;br&gt;options | <span class="co">[</span><span class="ot">v.what.strds</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/v.what.strds.html)</span> | <span class="co">[</span><span class="ot">v.what.strds.timestamp</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/v.what.strds.timestamp.html)</span> | <span class="co">[</span><span class="ot">v.strds.stats</span><span class="co">](https://grass.osgeo.org/grass-stable/manuals/addons/v.strds.stats.html)</span> |</span>
<span id="cb30-364"><a href="#cb30-364" aria-hidden="true" tabindex="-1"></a>|---|---|---|---|</span>
<span id="cb30-365"><a href="#cb30-365" aria-hidden="true" tabindex="-1"></a>| Purpose | Retrieves raster values from STRDSs using a point vector map | Matches points with timestamp in the attribute table with STRDSs based on point locations in space and time, and updates the input vector's attribute table | Calculates zonal statistics from STRDSs and uploads values to attribute columns of a new vector map |</span>
<span id="cb30-366"><a href="#cb30-366" aria-hidden="true" tabindex="-1"></a>| input | vector (points) and strds(s) | vector (points) and strds(s) | vector (lines or polygons) and strds(s) |</span>
<span id="cb30-367"><a href="#cb30-367" aria-hidden="true" tabindex="-1"></a>| output | vector | vector | vector |</span>
<span id="cb30-368"><a href="#cb30-368" aria-hidden="true" tabindex="-1"></a>| where | yes | yes | yes |</span>
<span id="cb30-369"><a href="#cb30-369" aria-hidden="true" tabindex="-1"></a>| t_where | yes | yes | yes |</span>
<span id="cb30-370"><a href="#cb30-370" aria-hidden="true" tabindex="-1"></a>| spatial aggr |  |  | yes |</span>
<span id="cb30-371"><a href="#cb30-371" aria-hidden="true" tabindex="-1"></a>| temporal aggr |  |  |  |</span>
<span id="cb30-372"><a href="#cb30-372" aria-hidden="true" tabindex="-1"></a>| spatial interp | | yes | |</span>
<span id="cb30-373"><a href="#cb30-373" aria-hidden="true" tabindex="-1"></a>| example | v.what.strds -u input=points strds=A  | v.what.strds.timestamp input=points timestamp_column=sampling_time column=A_at_sampling_time strds=A | v.strds.stats input=areas strds=A output=areas_new method=average |</span>
<span id="cb30-374"><a href="#cb30-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-375"><a href="#cb30-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-376"><a href="#cb30-376" aria-hidden="true" tabindex="-1"></a>Let's go through the usage of the vector tools to query raster time series now.</span>
<span id="cb30-377"><a href="#cb30-377" aria-hidden="true" tabindex="-1"></a>When we run *v.what.strds* to query strds we can either save the results in </span>
<span id="cb30-378"><a href="#cb30-378" aria-hidden="true" tabindex="-1"></a>a new vector map or update the input vector attribute table by setting the</span>
<span id="cb30-379"><a href="#cb30-379" aria-hidden="true" tabindex="-1"></a><span class="in">`u`</span> flag. In this case, we'll create a new vector map and do a temporal</span>
<span id="cb30-380"><a href="#cb30-380" aria-hidden="true" tabindex="-1"></a>selection.</span>
<span id="cb30-381"><a href="#cb30-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-384"><a href="#cb30-384" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-385"><a href="#cb30-385" aria-hidden="true" tabindex="-1"></a><span class="co"># Run v.what.strds with temporal selection</span></span>
<span id="cb30-386"><a href="#cb30-386" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds"</span>,</span>
<span id="cb30-387"><a href="#cb30-387" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-388"><a href="#cb30-388" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-389"><a href="#cb30-389" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"sp_lst_monthly_2014"</span>,</span>
<span id="cb30-390"><a href="#cb30-390" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"start_time &lt;= '2015-01-01'"</span>)</span>
<span id="cb30-391"><a href="#cb30-391" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-392"><a href="#cb30-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-393"><a href="#cb30-393" aria-hidden="true" tabindex="-1"></a>Let's check the new vector created. It contains a new column per map in the </span>
<span id="cb30-394"><a href="#cb30-394" aria-hidden="true" tabindex="-1"></a>queried strds.</span>
<span id="cb30-395"><a href="#cb30-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-398"><a href="#cb30-398" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-399"><a href="#cb30-399" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb30-400"><a href="#cb30-400" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sp_lst_monthly_2014"</span>, </span>
<span id="cb30-401"><a href="#cb30-401" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb30-402"><a href="#cb30-402" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb30-403"><a href="#cb30-403" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span>
<span id="cb30-404"><a href="#cb30-404" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-405"><a href="#cb30-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-406"><a href="#cb30-406" aria-hidden="true" tabindex="-1"></a>The tool *v.what.strds.timestamp* is an extension so we need to install it first.</span>
<span id="cb30-407"><a href="#cb30-407" aria-hidden="true" tabindex="-1"></a>It will by default update the input vector attribute table with a column that </span>
<span id="cb30-408"><a href="#cb30-408" aria-hidden="true" tabindex="-1"></a>needs to be specified by the user. Furthermore, it offers spatial interpolation </span>
<span id="cb30-409"><a href="#cb30-409" aria-hidden="true" tabindex="-1"></a>of the four nearest cells via the <span class="in">`i`</span> flag. Let's compare the results with and</span>
<span id="cb30-410"><a href="#cb30-410" aria-hidden="true" tabindex="-1"></a>without it.</span>
<span id="cb30-411"><a href="#cb30-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-414"><a href="#cb30-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-415"><a href="#cb30-415" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"v.what.strds.timestamp"</span>)</span>
<span id="cb30-416"><a href="#cb30-416" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-417"><a href="#cb30-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-420"><a href="#cb30-420" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-421"><a href="#cb30-421" aria-hidden="true" tabindex="-1"></a><span class="co"># with spatial interp of neighbor cells</span></span>
<span id="cb30-422"><a href="#cb30-422" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds.timestamp"</span>,</span>
<span id="cb30-423"><a href="#cb30-423" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-424"><a href="#cb30-424" aria-hidden="true" tabindex="-1"></a>               timestamp_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb30-425"><a href="#cb30-425" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_sampling_date_i"</span>,</span>
<span id="cb30-426"><a href="#cb30-426" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>,</span>
<span id="cb30-427"><a href="#cb30-427" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"i"</span>)</span>
<span id="cb30-428"><a href="#cb30-428" aria-hidden="true" tabindex="-1"></a>               </span>
<span id="cb30-429"><a href="#cb30-429" aria-hidden="true" tabindex="-1"></a><span class="co"># without spatial interp of neighbor cells</span></span>
<span id="cb30-430"><a href="#cb30-430" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.what.strds.timestamp"</span>,</span>
<span id="cb30-431"><a href="#cb30-431" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"sampling_points"</span>,</span>
<span id="cb30-432"><a href="#cb30-432" aria-hidden="true" tabindex="-1"></a>               timestamp_column<span class="op">=</span><span class="st">"sampling_date"</span>,</span>
<span id="cb30-433"><a href="#cb30-433" aria-hidden="true" tabindex="-1"></a>               column<span class="op">=</span><span class="st">"lst_sampling_date_no_i"</span>,</span>
<span id="cb30-434"><a href="#cb30-434" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_daily"</span>)</span>
<span id="cb30-435"><a href="#cb30-435" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-436"><a href="#cb30-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-437"><a href="#cb30-437" aria-hidden="true" tabindex="-1"></a>Let's check the results.</span>
<span id="cb30-438"><a href="#cb30-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-441"><a href="#cb30-441" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-442"><a href="#cb30-442" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb30-443"><a href="#cb30-443" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"sampling_points"</span>, </span>
<span id="cb30-444"><a href="#cb30-444" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb30-445"><a href="#cb30-445" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb30-446"><a href="#cb30-446" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data[<span class="st">'records'</span>])</span>
<span id="cb30-447"><a href="#cb30-447" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-448"><a href="#cb30-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-449"><a href="#cb30-449" aria-hidden="true" tabindex="-1"></a>Finally, we'll extract zonal statistics of a raster time series. For this, we</span>
<span id="cb30-450"><a href="#cb30-450" aria-hidden="true" tabindex="-1"></a>need either a line or polygon vector map as input. We'll use the map of</span>
<span id="cb30-451"><a href="#cb30-451" aria-hidden="true" tabindex="-1"></a>italian municipalities and demonstrate the use of spatial (<span class="in">`where`</span>) and temporal </span>
<span id="cb30-452"><a href="#cb30-452" aria-hidden="true" tabindex="-1"></a>(<span class="in">`t_where`</span>) selection.</span>
<span id="cb30-453"><a href="#cb30-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-456"><a href="#cb30-456" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-457"><a href="#cb30-457" aria-hidden="true" tabindex="-1"></a><span class="co"># Install v.strds.stats extension</span></span>
<span id="cb30-458"><a href="#cb30-458" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"g.extension"</span>, extension<span class="op">=</span><span class="st">"v.strds.stats"</span>)</span>
<span id="cb30-459"><a href="#cb30-459" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-460"><a href="#cb30-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-463"><a href="#cb30-463" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-464"><a href="#cb30-464" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract August average LST for Milano municipality</span></span>
<span id="cb30-465"><a href="#cb30-465" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.strds.stats"</span>,</span>
<span id="cb30-466"><a href="#cb30-466" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3"</span>,</span>
<span id="cb30-467"><a href="#cb30-467" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-468"><a href="#cb30-468" aria-hidden="true" tabindex="-1"></a>               where<span class="op">=</span><span class="st">"NAME_3 == 'Milano'"</span>,</span>
<span id="cb30-469"><a href="#cb30-469" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"strftime('%m', start_time)='08'"</span>,</span>
<span id="cb30-470"><a href="#cb30-470" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"milano_lst_august"</span>,</span>
<span id="cb30-471"><a href="#cb30-471" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span>
<span id="cb30-472"><a href="#cb30-472" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-473"><a href="#cb30-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-476"><a href="#cb30-476" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-477"><a href="#cb30-477" aria-hidden="true" tabindex="-1"></a>gs.vector_db_select(<span class="st">"milano_lst_august"</span>)[<span class="st">"values"</span>]</span>
<span id="cb30-478"><a href="#cb30-478" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-479"><a href="#cb30-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-480"><a href="#cb30-480" aria-hidden="true" tabindex="-1"></a>Let's now try to find out which municipality in northern Italy had the highest </span>
<span id="cb30-481"><a href="#cb30-481" aria-hidden="true" tabindex="-1"></a>August average temperature each year? </span>
<span id="cb30-482"><a href="#cb30-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-485"><a href="#cb30-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-486"><a href="#cb30-486" aria-hidden="true" tabindex="-1"></a><span class="co"># Clip municipalities to computational region</span></span>
<span id="cb30-487"><a href="#cb30-487" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.clip"</span>, </span>
<span id="cb30-488"><a href="#cb30-488" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3"</span>, </span>
<span id="cb30-489"><a href="#cb30-489" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"italy_borders_3_clip"</span>, </span>
<span id="cb30-490"><a href="#cb30-490" aria-hidden="true" tabindex="-1"></a>               flags<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb30-491"><a href="#cb30-491" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-492"><a href="#cb30-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-495"><a href="#cb30-495" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-496"><a href="#cb30-496" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract summer average LST municipalities</span></span>
<span id="cb30-497"><a href="#cb30-497" aria-hidden="true" tabindex="-1"></a>gs.run_command(<span class="st">"v.strds.stats"</span>,</span>
<span id="cb30-498"><a href="#cb30-498" aria-hidden="true" tabindex="-1"></a>               <span class="bu">input</span><span class="op">=</span><span class="st">"italy_borders_3_clip"</span>,</span>
<span id="cb30-499"><a href="#cb30-499" aria-hidden="true" tabindex="-1"></a>               strds<span class="op">=</span><span class="st">"lst_monthly"</span>,</span>
<span id="cb30-500"><a href="#cb30-500" aria-hidden="true" tabindex="-1"></a>               t_where<span class="op">=</span><span class="st">"strftime('%m', start_time)='08'"</span>,</span>
<span id="cb30-501"><a href="#cb30-501" aria-hidden="true" tabindex="-1"></a>               output<span class="op">=</span><span class="st">"municip_lst_august"</span>,</span>
<span id="cb30-502"><a href="#cb30-502" aria-hidden="true" tabindex="-1"></a>               method<span class="op">=</span><span class="st">"average"</span>)</span>
<span id="cb30-503"><a href="#cb30-503" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-504"><a href="#cb30-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-507"><a href="#cb30-507" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-508"><a href="#cb30-508" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the output table</span></span>
<span id="cb30-509"><a href="#cb30-509" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> gs.parse_command(<span class="st">"v.db.select"</span>, </span>
<span id="cb30-510"><a href="#cb30-510" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">map</span><span class="op">=</span><span class="st">"municip_lst_august"</span>, </span>
<span id="cb30-511"><a href="#cb30-511" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">"json"</span>)</span>
<span id="cb30-512"><a href="#cb30-512" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb30-513"><a href="#cb30-513" aria-hidden="true" tabindex="-1"></a>table <span class="op">=</span> pd.DataFrame(data[<span class="st">'records'</span>])</span>
<span id="cb30-514"><a href="#cb30-514" aria-hidden="true" tabindex="-1"></a>table</span>
<span id="cb30-515"><a href="#cb30-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-516"><a href="#cb30-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-519"><a href="#cb30-519" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb30-520"><a href="#cb30-520" aria-hidden="true" tabindex="-1"></a><span class="co"># List with column names</span></span>
<span id="cb30-521"><a href="#cb30-521" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="bu">list</span>(table.columns[<span class="op">-</span><span class="dv">5</span>:])</span>
<span id="cb30-522"><a href="#cb30-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-523"><a href="#cb30-523" aria-hidden="true" tabindex="-1"></a><span class="co"># Dictionary to store results</span></span>
<span id="cb30-524"><a href="#cb30-524" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb30-525"><a href="#cb30-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-526"><a href="#cb30-526" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols:</span>
<span id="cb30-527"><a href="#cb30-527" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the maximum value in the column</span></span>
<span id="cb30-528"><a href="#cb30-528" aria-hidden="true" tabindex="-1"></a>    max_value <span class="op">=</span> table[col].<span class="bu">max</span>()</span>
<span id="cb30-529"><a href="#cb30-529" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-530"><a href="#cb30-530" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the index of the row with the maximum value</span></span>
<span id="cb30-531"><a href="#cb30-531" aria-hidden="true" tabindex="-1"></a>    max_index <span class="op">=</span> table[col].idxmax()</span>
<span id="cb30-532"><a href="#cb30-532" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-533"><a href="#cb30-533" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the corresponding value in column 'D'</span></span>
<span id="cb30-534"><a href="#cb30-534" aria-hidden="true" tabindex="-1"></a>    municipality <span class="op">=</span> table.loc[max_index, <span class="st">"NAME_3"</span>]</span>
<span id="cb30-535"><a href="#cb30-535" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-536"><a href="#cb30-536" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the results</span></span>
<span id="cb30-537"><a href="#cb30-537" aria-hidden="true" tabindex="-1"></a>    results[col] <span class="op">=</span> {<span class="st">'max_value'</span>: max_value, <span class="st">'municipality'</span>: municipality}</span>
<span id="cb30-538"><a href="#cb30-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-539"><a href="#cb30-539" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the results</span></span>
<span id="cb30-540"><a href="#cb30-540" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, res <span class="kw">in</span> results.items():</span>
<span id="cb30-541"><a href="#cb30-541" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">':"</span>)</span>
<span id="cb30-542"><a href="#cb30-542" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Maximum value: </span><span class="sc">{</span>res[<span class="st">'max_value'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-543"><a href="#cb30-543" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Municipality name: </span><span class="sc">{</span>res[<span class="st">'municipality'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-544"><a href="#cb30-544" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb30-545"><a href="#cb30-545" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-546"><a href="#cb30-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-547"><a href="#cb30-547" aria-hidden="true" tabindex="-1"></a>The highest average temperature in August varied among years and municipalities, however, Campi Bisenzio in the province of Florence, had the highest value both in 2016 and 2017.  </span>
<span id="cb30-548"><a href="#cb30-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-549"><a href="#cb30-549" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- how to get the max of each new col --&gt;</span></span>
<span id="cb30-550"><a href="#cb30-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-551"><a href="#cb30-551" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- write the result --&gt;</span></span>
<span id="cb30-552"><a href="#cb30-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-553"><a href="#cb30-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-554"><a href="#cb30-554" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
<span id="cb30-555"><a href="#cb30-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-556"><a href="#cb30-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-557"><a href="#cb30-557" aria-hidden="true" tabindex="-1"></a>:::{.smaller}</span>
<span id="cb30-558"><a href="#cb30-558" aria-hidden="true" tabindex="-1"></a>Development of this tutorial was funded by the US </span>
<span id="cb30-559"><a href="#cb30-559" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">National Science Foundation (NSF)</span><span class="co">](https://www.nsf.gov/)</span>, </span>
<span id="cb30-560"><a href="#cb30-560" aria-hidden="true" tabindex="-1"></a>award <span class="co">[</span><span class="ot">2303651</span><span class="co">](https://www.nsf.gov/awardsearch/showAward?AWD_ID=2303651)</span>.</span>
<span id="cb30-561"><a href="#cb30-561" aria-hidden="true" tabindex="-1"></a>:::</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>